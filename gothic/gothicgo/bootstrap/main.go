package main

import (
	"text/template"

	"github.com/adamcolton/luce/util/luceio"

	"github.com/adamcolton/luce/gothic/gothicgo"
	"github.com/adamcolton/luce/gothic/gothicgo/ggutil"
)

var (
	test = template.Must(template.New("test").Parse(`func Test{{.Name}}TypeGen(t *testing.T){
		{{.Constructor}}

		assert.Equal(t, {{.Kind}}, x.Kind())
		assert.Equal(t, {{if .Package}}{{.Package}}{{else}}PkgBuiltin(){{end}}, x.PackageRef())

		n := x.Named("Foo")
		assert.Equal(t, "Foo", n.Name())
		assert.Equal(t, x, n.T)
	
		n = x.Unnamed()
		assert.Equal(t, "", n.Name())
		assert.Equal(t, x, n.T)
	
		p := x.Pointer()
		assert.Equal(t, PointerKind, p.Kind())
		assert.Equal(t, x, p.Elem())
	
		s := x.Slice()
		assert.Equal(t, SliceKind, s.Kind())
		assert.Equal(t, x, s.Elem())
	
		a := x.Array(13)
		assert.Equal(t, ArrayKind, a.Kind())
		assert.Equal(t, x, a.Elem())
	
		mp := x.AsMapElem(IntType)
		assert.Equal(t, MapKind, mp.Kind())
		assert.Equal(t, x, mp.Elem())
	
		mp = x.AsMapKey(IntType)
		assert.Equal(t, MapKind, mp.Kind())
		assert.Equal(t, x, mp.Key)

		{{if .Elem -}}
		assert.Equal(t, {{.Elem}}, x.Elem())
		{{end}}
		str := PrefixWriteToString(x, DefaultPrefixer)
		assert.Equal(t, "{{.String}}", str)
	}`))

	typegen = template.Must(template.New("typegen").Parse(`
	{{define "sig" -}}
		func ({{.R}} {{if .Ptr}}*{{end}}{{.Name}})
	{{- end -}}

	// Named fulfills Type. Returns a NameType with the given name.
	{{template "sig" .}} Named(name string) NameType { return NameType{name, {{.R}}} }

	// Unnamed funfills Type. Returns a NameType with an empty Name.
	{{template "sig" .}} Unnamed() NameType { return NameType{"", {{.R}}} }

	// Ptr funfills Type.
	{{template "sig" .}} Pointer() *PointerType { return PointerTo({{.R}}) }

	// Slice funfills Type.
	{{template "sig" .}} Slice() SliceType { return SliceOf({{.R}}) }

	// Array funfills Type.
	{{template "sig" .}} Array(size int) *ArrayType { return ArrayOf({{.R}}, size) }

	// AsMapElem funfills Type.
	{{template "sig" .}} AsMapElem(key Type) *MapType { return MapOf(key, {{.R}}) }

	// AsMapKey funfills Type. Returns a NameType with an empty Name.
	{{template "sig" .}} AsMapKey(elem Type) *MapType { return MapOf({{.R}}, elem) }

	{{if .GenKind -}}
	// Kind fulfills Type. Returns {{.Kind}}.
	{{template "sig" .}} Kind() Kind { return {{.Kind}} }
	{{- end}}
`))
)

type fullType struct {
	R, Name, Kind string
	GenKind, Ptr  bool

	// Test values
	Constructor, String, Package, Elem string
}

func main() {
	pth := "github.com/adamcolton/luce/gothic/"
	ctx := gothicgo.ContextFactory{
		OutputPath:     ggutil.GoSrc(pth),
		ImportPath:     pth,
		DefaultComment: "Generated by gothicgo/bootstrap - Do not modify",
	}.New()
	pkg := ctx.MustPackage("gothicgo")
	typeFile := pkg.File("type.gen")
	testFile := pkg.File("type.gen_test")

	testFile.Imports.Add(
		gothicgo.MustExternalPackageRef("testing"),
		gothicgo.MustExternalPackageRef("github.com/testify/assert"),
	)

	fts := []fullType{
		{
			R:           "a",
			Name:        "ArrayType",
			GenKind:     true,
			Ptr:         true,
			Constructor: "x := IntType.Array(5)",
			String:      "[5]int",
			Kind:        "ArrayKind",
			Elem:        "IntType",
		}, {
			R:           "b",
			Name:        "builtin",
			Constructor: "x := IntType",
			String:      "int",
			Kind:        "IntKind",
		}, {
			R:       "e",
			Name:    "ExternalType",
			GenKind: true,
			Ptr:     true,
			Constructor: `pkg := MustExternalPackageRef("foo")
						  x := pkg.MustExternalType("Bar")`,
			String:  "foo.Bar",
			Kind:    "TypeDefKind",
			Package: `pkg`,
		}, {
			R:       "f",
			Name:    "FuncSig",
			GenKind: true,
			Ptr:     true,
			Constructor: `	args := []NameType{
								IntType.Named("a"),
								StringType.Named("b"),
							}
							x := NewFuncSig("Foo", args...).
								UnnamedRets(StringType)`,
			String: "func Foo(a int, b string) string",
			Kind:   "FuncKind",
		}, {
			R:           "m",
			Name:        "MapType",
			GenKind:     true,
			Ptr:         true,
			Constructor: "x := MapOf(IntType, StringType)",
			String:      "map[int]string",
			Kind:        "MapKind",
			Elem:        "StringType",
		},
		{
			R:           "p",
			Name:        "PointerType",
			GenKind:     true,
			Ptr:         true,
			Constructor: "x := IntType.Pointer()",
			String:      "*int",
			Kind:        "PointerKind",
			Elem:        "IntType",
		},
	}
	for _, ft := range fts {
		typeFile.AddWriterTo(&luceio.TemplateTo{
			TemplateExecutor: typegen,
			Data:             ft,
		})
		testFile.AddWriterTo(&luceio.TemplateTo{
			TemplateExecutor: test,
			Data:             ft,
		})
	}

	ctx.MustExport()
}
